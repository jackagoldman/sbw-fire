}
res <- nbr_slope(nbrsbw_data)
View(res)
daata = test <- nbrsbw_data |>
filter(Fire_ID == "CHA19_2000_60" )
x <- data |>
select(c(Fire_ID, nbr10, nbr1, nbr2, nbr3, nbr4, nbr5, nbr6, nbr7, nbr8, nbr9)) |>
pivot_longer(!Fire_ID, names_to = "Recovery_Time", values_to = "nbr" ) |>
mutate(recovery_interval = case_when(Recovery_Time == "nbr1" ~ 1,
Recovery_Time == "nbr2" ~ 1,
Recovery_Time == "nbr3" ~ 1,
Recovery_Time == "nbr4" ~ 1,
Recovery_Time == "nbr5" ~ 1,
Recovery_Time == "nbr6" ~ 2,
Recovery_Time == "nbr7" ~ 2,
Recovery_Time == "nbr8" ~ 2,
Recovery_Time == "nbr9" ~ 2,
Recovery_Time == "nbr10" ~ 2,))
mylist <- list()
#subset data
row <- x[i,]
i = 1
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
data1 <- row2 |> filter(recovery_interval == 1)
data2 <- row2 |> filter(recovery_interval == 2)
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- as.data.frame(slope1[1])
sens2 <- as.data.frame(slope2[1])
sens_ci1 <- as.data.frame(slope1[9])
sens_ci2 <- as.data.frame(slope2[9])
uppr1 <- sens_ci1[2,1]
uppr2 <- sens_ci2[2,1]
lwr1 <- sens_ci1[1,1]
lwr2 <- sens_ci2[1,1]
uppr1 <- sens_ci1[2,1]
sens1
slope1
ts1 <- ts(data1, start =1, frequency = 10)
View(ts1)
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr)
data2 <- row2 |> filter(recovery_interval == 2)|> select(c(nbr)
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
data1 <- row2 |> filter(recovery_interval == 1) |>
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
data1 <- row2 |> filter(recovery_interval == 1)
View(data1)
data11 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
View(data11)
ts1 <- ts(data1, start =1, frequency = 10)
ts1 <- ts(data11, start =1, frequency = 10)
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope1
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
View(vec)
sens1 <- as.data.frame(slope1[1])
View(sens1)
sens1 <- sens1[1,1]
sens2 <- sens2[1,1]
sens2 <- as.data.frame(slope2[1])
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data11, start =1, frequency = 10)
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- as.data.frame(slope1[1])
sens2 <- as.data.frame(slope2[1])
sens1 <- sens1[1,1]
sens2 <- sens2[1,1]
sens_ci1 <- as.data.frame(slope1[9])
sens_ci2 <- as.data.frame(slope2[9])
uppr1 <- sens_ci1[2,1]
uppr2 <- sens_ci2[2,1]
lwr1 <- sens_ci1[1,1]
lwr2 <- sens_ci2[1,1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
mylist <- list()
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
View(vec)
View(vec)
vec <-  vec[1:11]
View(vec)
# slope function
nbr_slope <- function(data){
require(trend)
x <- data |>
select(c(Fire_ID, nbr10, nbr1, nbr2, nbr3, nbr4, nbr5, nbr6, nbr7, nbr8, nbr9)) |>
pivot_longer(!Fire_ID, names_to = "Recovery_Time", values_to = "nbr" ) |>
mutate(recovery_interval = case_when(Recovery_Time == "nbr1" ~ 1,
Recovery_Time == "nbr2" ~ 1,
Recovery_Time == "nbr3" ~ 1,
Recovery_Time == "nbr4" ~ 1,
Recovery_Time == "nbr5" ~ 1,
Recovery_Time == "nbr6" ~ 2,
Recovery_Time == "nbr7" ~ 2,
Recovery_Time == "nbr8" ~ 2,
Recovery_Time == "nbr9" ~ 2,
Recovery_Time == "nbr10" ~ 2,))
mylist <- list()
i = 1
#loop
for(i in 1:nrow(x)){
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
summary(mod1)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
# sens slope
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- as.data.frame(slope1[1])
sens2 <- as.data.frame(slope2[1])
sens1 <- sens1[1,1]
sens2 <- sens2[1,1]
sens_ci1 <- as.data.frame(slope1[9])
sens_ci2 <- as.data.frame(slope2[9])
uppr1 <- sens_ci1[2,1]
uppr2 <- sens_ci2[2,1]
lwr1 <- sens_ci1[1,1]
lwr2 <- sens_ci2[1,1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
vec <-  vec[1:11]
mylist[[i]] <- vec
i+1
}
res <- do.call(rbind, mylist)
res <- res |> as.tibble(.name_repair = 'unique') |>
group_by(fId) %>%
slice_head(n = 1) |>
unnest()
}
res <- nbr_slope(nbrsbw_data)
View(res)
View(sens_ci1)
View(sens_ci2)
View(slope)
View(slope1)
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
summary(mod1)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- as.data.frame(slope1[1])
sens2 <- as.data.frame(slope2[1])
sens1 <- sens1[1,1]
sens2 <- sens2[1,1]
sens_ci1 <- as.data.frame(slope1[9])
sens_ci2 <- as.data.frame(slope2[9])
uppr1 <- sens_ci1[2,1]
uppr2 <- sens_ci2[2,1]
lwr1 <- sens_ci1[1,1]
lwr2 <- sens_ci2[1,1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
View(vec)
vec <-  vec[1:11]
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
View(vec)
sens1
vec <- c(fId, slope1, slope2, se1, se2, as.numeric(sens1), sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
library(janitor)
install.packages("janitor")
library(janitor)
require(broom)
slope1 <- sens.slope(ts1, conf.level = 0.95) |> broom::tidy()
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope1 <- sens.slope(ts1, conf.level = 0.95) |> broom::tidy()
sens1 <- slope1$estimate
slope1 <- sens.slope(ts1, conf.level = 0.95) )
slope1
slope1 <- sens.slope(ts1, conf.level = 0.95)
slope1
sens1 <- slope1$estimates
sens2 <- slope2$estimates
slope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- slope1$estimates
sens2 <- slope2$estimates
uppr1 <- slope1$conf.high
uppr1 <- slope1$conf.int
uppr1 <- slope1$conf.int[2]
uppr2 <- slope2$conf.int[2]
lwr1 <- slope1$conf.int[1]
lwr2 <- slope2$conf.int[1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
View(vec)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
sslope1 <- sens.slope(ts1, conf.level = 0.95)
sslope2 <- sens.slope(ts2, conf.level = 0.95)
df <- as.data.frame(c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2))
View(df)
names(df) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
#loop
for(i in 1:nrow(x)){
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
summary(mod1)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
# sens slope
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
sslope1 <- sens.slope(ts1, conf.level = 0.95)
sslope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- sslope1$estimates
sens2 <- sslope2$estimates
uppr1 <- sslope1$conf.int[2]
uppr2 <- sslope2$conf.int[2]
lwr1 <- sslope1$conf.int[1]
lwr2 <- sslope2$conf.int[1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
vec <-  vec[1:11]
mylist[[i]] <- vec
i+1
}
View(vec)
test <- nbrsbw_data |>
filter(Fire_ID == "CHA19_2000_60" ) |>
select(c(nbr1:nbr9)) |>
relocate(nbr10, .after = nbr9)
# slope function
nbr_slope <- function(data){
require(trend)
require(broom)
x <- data |>
select(c(Fire_ID, nbr10, nbr1, nbr2, nbr3, nbr4, nbr5, nbr6, nbr7, nbr8, nbr9)) |>
pivot_longer(!Fire_ID, names_to = "Recovery_Time", values_to = "nbr" ) |>
mutate(recovery_interval = case_when(Recovery_Time == "nbr1" ~ 1,
Recovery_Time == "nbr2" ~ 1,
Recovery_Time == "nbr3" ~ 1,
Recovery_Time == "nbr4" ~ 1,
Recovery_Time == "nbr5" ~ 1,
Recovery_Time == "nbr6" ~ 2,
Recovery_Time == "nbr7" ~ 2,
Recovery_Time == "nbr8" ~ 2,
Recovery_Time == "nbr9" ~ 2,
Recovery_Time == "nbr10" ~ 2,))
mylist <- list()
#loop
for(i in 1:nrow(x)){
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
summary(mod1)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
# sens slope
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
sslope1 <- sens.slope(ts1, conf.level = 0.95)
sslope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- sslope1$estimates
sens2 <- sslope2$estimates
uppr1 <- sslope1$conf.int[2]
uppr2 <- sslope2$conf.int[2]
lwr1 <- sslope1$conf.int[1]
lwr2 <- sslope2$conf.int[1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
vec <-  vec[1:11]
mylist[[i]] <- vec
i+1
}
res <- do.call(rbind, mylist)
res <- res |> as.tibble(.name_repair = 'unique') |>
group_by(fId) %>%
slice_head(n = 1) |>
unnest()
}
# slope function
nbr_slope <- function(data){
require(trend)
x <- data |>
select(c(Fire_ID, nbr10, nbr1, nbr2, nbr3, nbr4, nbr5, nbr6, nbr7, nbr8, nbr9)) |>
pivot_longer(!Fire_ID, names_to = "Recovery_Time", values_to = "nbr" ) |>
mutate(recovery_interval = case_when(Recovery_Time == "nbr1" ~ 1,
Recovery_Time == "nbr2" ~ 1,
Recovery_Time == "nbr3" ~ 1,
Recovery_Time == "nbr4" ~ 1,
Recovery_Time == "nbr5" ~ 1,
Recovery_Time == "nbr6" ~ 2,
Recovery_Time == "nbr7" ~ 2,
Recovery_Time == "nbr8" ~ 2,
Recovery_Time == "nbr9" ~ 2,
Recovery_Time == "nbr10" ~ 2,))
mylist <- list()
#loop
for(i in 1:nrow(x)){
#subset data
row <- x[i,]
#get fire id
fId <- row |> select(c(Fire_ID)) |> slice(1)
# subset data for fire id
row2 <- x |> filter(Fire_ID == c(fId))
#run first model
mod1 <- lm(nbr ~ (recovery_interval == 1), data = row2)
#run second model
mod2 <- lm(nbr ~ (recovery_interval == 2), data = row2)
summary(mod1)
#get coefficients
cf1 <- coef(mod1)
cf2 <- coef(mod2)
#get slope
slope1 <- cf1[2]
slope2 <- cf2[2]
#get se
se1 <- sqrt(diag(vcov(mod1)))[2]
se2 <- sqrt(diag(vcov(mod2)))[2]
# sens slope
data1 <- row2 |> filter(recovery_interval == 1) |> select(c(nbr))
data2 <- row2 |> filter(recovery_interval == 2) |> select(c(nbr))
ts1 <- ts(data1, start =1, frequency = 10)
ts2 <- ts(data2, start =1, frequency = 10)
sslope1 <- sens.slope(ts1, conf.level = 0.95)
sslope2 <- sens.slope(ts2, conf.level = 0.95)
sens1 <- sslope1$estimates
sens2 <- sslope2$estimates
uppr1 <- sslope1$conf.int[2]
uppr2 <- sslope2$conf.int[2]
lwr1 <- sslope1$conf.int[1]
lwr2 <- sslope2$conf.int[1]
vec <- c(fId, slope1, slope2, se1, se2, sens1, sens2, uppr1, uppr2, lwr1, lwr2)
names(vec) <- c("fId", "slope1", "slope2", "se1", "se2", "sens1", "sens2", "uppr1", "uppr2", "lwr1", "lwr2")
vec <-  vec[1:11]
mylist[[i]] <- vec
i+1
}
res <- do.call(rbind, mylist)
res <- res |> as.tibble(.name_repair = 'unique') |>
group_by(fId) %>%
slice_head(n = 1) |>
unnest()
}
res <- nbr_slope(nbrsbw_data)
View(res)
res$Fire_ID <- res$fId
res <- res |>
select(-c(fId))
nbrsbw_data <- nbrsbw_data |>
left_join(res, by="Fire_ID")
nbrsbw_data <- nbrsbw_data |>
select(-c(fId))
write.csv(nbrsbw_data, "data/clean/nbr-sbw-slope-data.csv")
View(nbrsbw_data)
View(nbrsbw_data)
nbrsbw_data <- nbrsbw_data |>
select(-c(slope1.y, slope2.y, se1.y, se2.y)) |>
gsub(x = names(.), pattern = ".x", replacement = "")
nbrsbw_data <- read.csv("data/clean/nbr-sbw-slope-data.csv")
nbrsbw_data <- nbrsbw_data |>
select(-c(slope1.y, slope2.y, se1.y, se2.y, X.1, X))
nbr1 <-  gsub(x = names(nbrsbw_data), pattern = ".x", replacement = "")
names(nbrsbw_data) <-  gsub(x = names(nbrsbw_data), pattern = ".x", replacement = "")
View(nbrsbw_data)
write.csv(nbrsbw_data, "data/clean/nbr-sbw-slope-data.csv")
summary(lm(sens1 ~ defol, data = nbrsbw_data))
boxplot(slens2 ~ defol, data = nbrsbw_data)
boxplot(sens2 ~ defol, data = nbrsbw_data)
boxplot(sens1 ~ defol, data = nbrsbw_data)
boxplot(sens2 ~ defol, data = nbrsbw_data)
summary(lm(sens12 ~ defol, data = nbrsbw_data))
summary(lm(sens2 ~ defol, data = nbrsbw_data))
summary(lm(slope1 ~ defol, data = nbrsbw_data))
install.packages("vegan")
install.packages("vegan")
install.packages("vegan")
library(vegan)
data(dune) # Vegetation and Environment in Dutch Dune Meadows
str(dune)
samp.dune <- dune[, 1:10]
samp.dune.hel <- decostand(samp.dune, method = "hellinger")
pca.samp.dune <-  rda(samp.dune.hel)
summary(pca.samp.dune)
eig1 <- pca.samp.dune$CA$eig[1]
eig2 <- pca.samp.dune$CA$eig[2]
eig3 <- pca.samp.dune$CA$eig[3]
eig4 <- pca.samp.dune$CA$eig[4]
eig5 <- pca.samp.dune$CA$eig[5]
eig6 <- pca.samp.dune$CA$eig[6]
eig7 <- pca.samp.dune$CA$eig[7]
eig8 <- pca.samp.dune$CA$eig[8]
eig9 <- pca.samp.dune$CA$eig[9]
eig10 <- pca.samp.dune$CA$eig[10]
sum <- eig1 + eig2 + eig3 + eig4 + eig5 + eig6 + eig7 + eig8 + eig9 + eig10
var1 <- (eig1 / sum)
var2 <- (eig2/sum)
var1
scores(pca.samp.dune,
display = "species")
scores(pca.samp.dune,
display = "sites")
eigs <- pca.samp.dune$CA$eig
eigs[eigs > mean(eigs)]
n <- length(eigs)
mean_eigs <- mean(eigs)
{barplot(eigs, main = "", col = "grey", las = 2)
abline(h = mean_eigs, col = "red3", lwd = 2)
legend("topright", "Average eigenvalue", lwd = 2, col = "red3",bty = n)}
biplot(pca.samp.dune)
biplot(pca.samp.dune, choices =c(1,3))
```{r type 2}
biplot(pca.samp.dune, scaling = 2)
biplot(pca.samp.dune, scaling = 1)
data(BCI)
str(BCI)
